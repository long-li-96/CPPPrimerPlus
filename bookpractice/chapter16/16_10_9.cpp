// 相对于数组，在链表中添加和删除元素更容易，但排序速度更慢，这就引出了一种可能性：相对于
// 使用链表算法进行排序，将链表复制到数组中，对数组排序，再将排序后的结果复制到链表中
// 的速度可能更快，但这也可能占用更多的内存。请使用如下方法检验上述假设。
// a 创建大型vector<int>对象vi0，并使用rand()给它提供初始值
// b 创建vector<int>对象vi 和 list<int>对象li，它们的长度和初始值与vi0相同
// c 计算使用STL算法sort()对vi进行排序所需的时间，再计算使用list的方法sort()对li进行排序所需要的时间
// d 将li重置为排序的vi0的内容，并计算执行如下操作所需的时间：将li的内容复制到vi中，对vi进行排序，并将结果复制到li中。
// 计算操作所需时间，可使用ctime库中的clock()，如waitting.cpp使用clock_t start = clock()来获取开始时间
// 操作结束后，使用clock_t end = clock(); double (end - start) / CLOCKS_PER_SEC来获取操作时间
// 结果取决于很多因素如可用内存量、是否支持多处理以及数组(列表)的长度.编译器提供了默认生成方式
// 和发布生成方式，则使用发布生成